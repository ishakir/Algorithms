1.  
	0.	O T Y E
	1.	U A
	2.	Q
	3.	
	4.	N I S
	
2.  Not Done
3.  Not Done
4.  Not Done
	Partially implemented in search.symboltable.misc.PerfectHash
	Found a solution with M=20, and a=1. had to take a guess at where to stop searching up through the values of a.
	It's intuitive that there's somewhere to stop. Guess is that it's at M which leads to the solution given
	but have not proven this
5.  It is legal, yes, in the sense that java will permit you to run it. The problem is that all objects of
	this type will collide when hashed, which will lead to large chains in separate chaining or linear probing
	collision resolution. Put / Get operations will be O(n), getting rid of all the advantages of hashing.
6.  Not Done
7.  Not Done
8.  Not Done
9.  Not Done
10. Not Done
11. Not Done
12. Not Done
13. Not Done
14. Not Done
15. Not Done
16. Not Done
17. Not Done
18. Not Done
19. Not Done
20. Not Done
21. Not Done
22. Not Done
23. Not Done
24. Not Done
25. Not Done
26. Not Done
27. Not Done
28. Not Done
29. Not Done
30. Not Done
31. Not Done
32. Not Done
33. Not Done
34. Not Done
35. Not Done
36. Not Done
37. Not Done
38. Not Done
39. Not Done
40. Not Done
41. Not Done
42. Not Done
43. Not Done